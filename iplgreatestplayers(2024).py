# -*- coding: utf-8 -*-
"""IPLGREATESTPLAYERS(2024).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_L5T7v8IOhmkFxVpSz0KiIz-7OtgE6P7

IPL BEST PLAYER ANALYSIS

Libary
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

import warnings
warnings.filterwarnings("ignore")
pd.set_option('display.max_columns',None)

matches = pd.read_csv('matches.csv')
balls = pd.read_csv('IPL_BallByBall2008_2024(Updated).csv')

matches.head()

print(matches.shape)
print('------------')
print(matches.isnull().sum())
print('------------')
print(matches.info())

matches[matches['winner'].isna()]

#remove unwanted columns
matches.drop(['city','id','method'],axis=1,inplace=True)
matches = matches.dropna()

matches.head()

matches['date'] = pd.to_datetime(matches['date'])

#convert the column types to their respective datatypes
matches['SEASON_INT'] = matches['season'].apply(lambda x: int(x[:4]))
matches['SEASON_END'] = matches['season'].apply(lambda x: int("20"+str(x[5:])) if len(x)>5 else int(x[:4]))

matches.drop(['season'],axis=1,inplace=True)

matches['winner'].unique()

matches['team1'] = matches['team1'].str.replace('Delhi Daredevils','Delhi Capitals')
matches['team2'] = matches['team2'].str.replace('Delhi Daredevils','Delhi Capitals')
matches['winner'] = matches['winner'].str.replace('Delhi Daredevils','Delhi Capitals')

matches['team1'] = matches['team1'].str.replace('Kings XI Punjab','Punjab Kings')
matches['team2'] = matches['team2'].str.replace('Kings XI Punjab','Punjab Kings')
matches['winner'] = matches['winner'].str.replace('Kings XI Punjab','Punjab Kings')

matches['team1'] = matches['team1'].str.replace('Deccan Chargers','Sunrisers Hyderabad')
matches['team2'] = matches['team2'].str.replace('Deccan Chargers','Sunrisers Hyderabad')
matches['winner'] = matches['winner'].str.replace('Deccan Chargers','Sunrisers Hyderabad')


matches['team1'] = matches['team1'].str.replace('Rising Pune Supergiant', 'Pune Warriors')
matches['team2'] = matches['team2'].str.replace('Rising Pune Supergiant', 'Pune Warriors')
matches['winner'] = matches['winner'].str.replace('Rising Pune Supergiant', 'Pune Warriors')

matches['team1'] = matches['team1'].str.replace('Rising Pune Supergiants', 'Pune Warriors')
matches['team2'] = matches['team2'].str.replace('Rising Pune Supergiants', 'Pune Warriors')
matches['winner'] = matches['winner'].str.replace('Rising Pune Supergiants', 'Pune Warriors')

matches['team1'] = matches['team1'].str.replace('Gujarat Lions', 'Gujarat Titans')
matches['team2'] = matches['team2'].str.replace('Gujarat Lions', 'Gujarat Titans')
matches['winner'] = matches['winner'].str.replace('Gujarat Lions', 'Gujarat Titans')

matches.head()

"""Ball by Ball DataFrame"""

balls.head()

print(balls.shape)
print('------------')
print(balls.isnull().sum())
print('------------')
print(balls.info())

batgroup = balls.groupby(['Striker'])
bat_stats = pd.DataFrame(batgroup['Ball No'].count()).rename(columns={'Ball No':'Balls_Faced'})
bat_stats.head()

bat_stats['Innings No'] = batgroup['Innings No'].nunique()
bat_stats.head()

bat_stats['Runs'] = batgroup['runs_scored'].sum()
bat_stats.head()

bat_stats['0s'] = balls[balls['runs_scored'] == 0].groupby('Striker')['runs_scored'].count()
bat_stats['0s'].fillna(0,inplace=True)
bat_stats.head()

bat_stats['1s'] = balls[balls['runs_scored']==1].groupby('Striker')['runs_scored'].count()
bat_stats['1s'].fillna(0,inplace=True)
bat_stats.head()

bat_stats['2s'] = balls[balls['runs_scored']==2].groupby('Striker')['runs_scored'].count()
bat_stats['2s'].fillna(0,inplace=True)
bat_stats['3s'] = balls[balls['runs_scored']==3].groupby('Striker')['runs_scored'].count()
bat_stats['3s'].fillna(0,inplace=True)
bat_stats['4s'] = balls[balls['runs_scored']==4].groupby('Striker')['runs_scored'].count()
bat_stats['4s'].fillna(0,inplace=True)
bat_stats['6s'] = balls[balls['runs_scored']==6].groupby('Striker')['runs_scored'].count()
bat_stats['6s'].fillna(0,inplace=True)
bat_stats.head()

bat_stats['Player Out'] = batgroup['Player Out'].count()
bat_stats.head()

bat_stats['Batter Avg'] = round(bat_stats['Runs']/bat_stats['Player Out'],2)
bat_stats['Strike Rate']  = round((bat_stats['Runs']/bat_stats['Balls_Faced'])*100,2)
bat_stats.head()

bowlgroup = balls.groupby(['Bowler'])
bowler_stats = pd.DataFrame(bowlgroup['Ball No'].count()).rename(columns={'Ball No':'Ball_Thrown'})
bowler_stats.head()

bowler_stats['Wickets'] = balls[balls['wicket_type'].isin(['caught','bowled', 'lbw','stumped', 'caught and bowled', 'hit wicket'])].groupby('Bowler')['wicket_confirmation'].count()
bowler_stats.head()

bowler_stats['Overs'] = round(bowler_stats['Ball_Thrown']/6,1)
bowler_stats.head()

bowler_stats['Runs_conceded'] = balls.groupby('Bowler')['runs_scored'].sum()
bowler_stats['Runs_conceded'] = bowler_stats['Runs_conceded'].fillna(0)
bowler_stats.head()

bowler_stats['Runs_conceded'] = bowler_stats['Runs_conceded'].add(balls[balls['type of extras'].isin(['wides','noballs'])].groupby('Bowler')['extras'].sum(),fill_value=0)

bowler_stats['Economy'] = round(bowler_stats['Runs_conceded']/bowler_stats['Overs'],2)
bowler_stats['bowl_strikerate'] = round(bowler_stats['Ball_Thrown']/bowler_stats['Wickets'],2)
bowler_stats.head()

players_matches_dict = {}

# Iterate over each row in the dataframe
for i, row in balls.iterrows():
    # Check if the batter is already in the dictionary
    if row['Striker'] in players_matches_dict:
        players_matches_dict[row['Striker']].add(row['Match id'])
    else:
        players_matches_dict[row['Striker']] = {row['Match id']}

    # Check if the non-striker is already in the dictionary
    if row['Non Striker'] in players_matches_dict:
        players_matches_dict[row['Non Striker']].add(row['Match id'])
    else:
        players_matches_dict[row['Non Striker']] = {row['Match id']}

    # Check if the bowler is already in the dictionary
    if row['Bowler'] in players_matches_dict:
        players_matches_dict[row['Bowler']].add(row['Match id'])
    else:
        players_matches_dict[row['Bowler']] = {row['Match id']}

# Create a dataframe with players and their number of matches
final_players_matches = pd.DataFrame({'Players': list(players_matches_dict.keys())})
final_players_matches['matches'] = final_players_matches['Players'].apply(lambda x: len(players_matches_dict[x]))
final_players_matches = final_players_matches.set_index('Players')

final_players_matches.head()

"""
# Catches Caught by Players
outbyCatch = balls[(balls['kind'].isin(['caught and bowled']))].groupby('bowler')['ballnumber'].count().rename('bowler_catches')
justCatch = balls[(balls['kind'].isin(['caught']))].groupby('fielders_involved')['ballnumber'].count().rename('fielder_catches')

catchDf = pd.merge(outbyCatch,justCatch, left_index=True, right_index=True,how='outer')
catchDf.fillna(0,inplace=True)
catchDf['catches'] = catchDf['bowler_catches']+catchDf['fielder_catches']
catchDf.drop(['bowler_catches','fielder_catches'],axis=1,inplace=True)"""

outbyCatch  = balls[(balls['wicket_type'].isin(['caught and bowled']))].groupby('Bowler')['Ball No'].count().rename("bowler_catches")
justCatch = balls[(balls['wicket_type'].isin(['caught']))].groupby('fielders_involved')['Ball No'].count().rename('fielder_catches')

catchDF = pd.merge(outbyCatch,justCatch, left_index=True, right_index=True,how='outer')
catchDF.fillna(0,inplace=True) # Use catchDF consistently
catchDF['catches'] = catchDF['bowler_catches']+catchDF['fielder_catches']
catchDF.drop(['bowler_catches','fielder_catches'],axis=1,inplace=True)

# Merging Batsman Stats
final_df = pd.merge(final_players_matches,bat_stats, left_index=True, right_index=True,how='outer')
# Merging Bowler Stats
final_df = pd.merge(final_df,bowler_stats, left_index=True, right_index=True,how='outer')
# Merging Catches Stats of Each Player
final_df = pd.merge(final_df,catchDF, left_index=True, right_index=True,how='outer')
# Merging the data of players who got Man of the Match of not
final_df = pd.merge(final_df,matches['player_of_match'].value_counts(),left_index=True, right_index=True,how='left')
# Making all the NAN values to 0 because they don't have the values Like a person who does not get Player of the Match is marked as NaN so I Make it 0
final_df.fillna(0,inplace=True)

final_df.head(10)

!pip install plotly_express
import plotly.express as px

# Create the scatter plot to see the Most 0s on the balls they Faced by a Batsman
fig = px.scatter(final_df, x='matches', y='0s',color='0s',
                 size='0s', hover_name=final_df.index, title='Most 0s by a Batsman for each ball they face')
fig.update_layout(coloraxis=dict(colorscale='blues'))

# Show the plot
fig.show()

# Calculate the ratio of matches to player_out
final_df['not_out'] = final_df['matches'] - final_df['Player Out']

# Create the scatter plot to see the Most Time Out by a Batsman
fig = px.scatter(final_df, x='Player Out', y='not_out', color='Runs',
                 size='Player Out', hover_name=final_df.index,
                 title='Most Time Out by a Batsman vs Matches Played to Player Not Out Matches')
fig.update_layout(coloraxis=dict(colorscale='blues'))

# Show the plot
fig.show()

final_df = final_df[final_df['matches']>50]
final_df.head()

plt.figure(figsize=(20,10))
sns.heatmap(final_df.corr(),annot=True)

def correlation(data, threshold):
    corr_matrix = data.corr()
    upper_triangle = corr_matrix.where(np.triu(np.ones(corr_matrix.shape), k=1).astype(bool))
    col_corr = [col for col in upper_triangle.columns if any(upper_triangle[col] > threshold)]
    return col_corr

corr_cols = correlation(final_df,0.85)
corr_cols

top_columns =final_df.drop(['Runs',
 '0s',
 '1s',
 '2s',
 '3s',
 '4s',
 '6s',
 'Player Out',
 'Wickets',
 'Overs',
 'Runs_conceded',
 'catches','not_out'],axis=1)

final_df_new = top_columns[np.isfinite(top_columns).all(1)]
final_df_new.head()

from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans

scaler = StandardScaler()
scaled_data = pd.DataFrame(
    scaler.fit_transform(final_df_new),
    columns=top_columns.columns,
    index=final_df_new.index
)
scaled_data.head()

clusters=range(1,12)
errors=[]
for k in clusters:
    model = KMeans(n_clusters=k)
    model.fit(scaled_data)
    errors.append(model.inertia_)
plt.xlabel('K')
plt.ylabel('Errors')
plt.plot(clusters,errors,'bx-')

model = KMeans(n_clusters = 4)
y_pred = model.fit_predict(scaled_data)
final_df_new['cluster'] = y_pred

final_df_new.reset_index(inplace=True)
topPlayers = final_df_new.rename(columns = {'index':'PlayerNames'})
topPlayers_cluster = pd.DataFrame(topPlayers[['PlayerNames','cluster']])

teams1 = topPlayers_cluster.loc[topPlayers_cluster['cluster']==0]
teams1 = teams1['PlayerNames'].tolist()

teams2 = topPlayers_cluster.loc[topPlayers_cluster['cluster']==1]
teams2 = teams2['PlayerNames'].tolist()

teams3 = topPlayers_cluster.loc[topPlayers_cluster['cluster']==2]
teams3 = teams3['PlayerNames'].tolist()

teams4 = topPlayers_cluster.loc[topPlayers_cluster['cluster']==3]
teams4 = teams4['PlayerNames'].tolist()

TopPlayer_Dataset = pd.DataFrame(teams1,columns=['GOODPLAYERS'])

TopPlayer_Dataset['BESTPLAYERS']=pd.Series(teams2)
TopPlayer_Dataset['GREATPLAYERS']=pd.Series(teams3)
TopPlayer_Dataset['GOATEDPLAYERS']=pd.Series(teams4)
TopPlayer_Dataset = TopPlayer_Dataset.fillna('')

TopPlayer_Dataset